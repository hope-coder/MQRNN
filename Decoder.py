import tensorflow as tf


class GlobalDecoder(tf.keras.Model):
    """
    解码器，注意这里的解码器输入的协变量大小是未来已知协变量的大小
    """

    def __init__(self,
                 hidden_size: int,
                 covariate_size: int,
                 horizon_size: int,
                 context_size: int):
        super(GlobalDecoder, self).__init__()
        self.hidden_size = hidden_size
        self.covariate_size = covariate_size
        self.horizon_size = horizon_size
        self.context_size = context_size

        self.linear1 = tf.keras.layers.Dense(units=horizon_size * hidden_size * 3, activation="relu")

        self.linear2 = tf.keras.layers.Dense(units=horizon_size * hidden_size * 2, activation="relu")

        # 时间步加一是指在输出时需要多输出一个时间步的信息作为全局信息
        self.linear3 = tf.keras.layers.Dense(units=(horizon_size + 1) * context_size, activation="relu")

    def call(self, inputs, training=None, mask=None):
        # in_features=hidden_size + covariate_size*horizon_size
        layer1_output = self.linear1(inputs)

        layer2_output = self.linear2(layer1_output)

        layer3_output = self.linear3(layer2_output)
        return layer3_output


class LocalDecoder(tf.keras.Model):
    """
    Based on the resulting tensor generated by the GlobalDecoder and the 
    covariate time series value at prediction step.

    input_size: (horizon_size+1)*context_size + horizon_size*covariate_size
    output_size: horizon_size * quantile_size
    """

    def __init__(self,
                 covariate_size,
                 context_size,
                 quantiles,
                 horizon_size):
        super(LocalDecoder, self).__init__()
        self.covariate_size = covariate_size
        self.quantiles = quantiles
        self.quantile_size = len(quantiles)
        self.horizon_size = horizon_size
        self.context_size = context_size

        self.linear1 = tf.keras.layers.Dense(units=horizon_size * context_size, activation="relu")
        self.linear2 = tf.keras.layers.Dense(units=horizon_size * self.quantile_size, activation="relu")

    def call(self, inputs, training=None, mask=None):
        # in_features=horizon_size*context_size + horizon_size * covariate_size + context_size
        layer1_output = self.linear1(inputs)

        layer2_output = self.linear2(layer1_output)

        return layer2_output
